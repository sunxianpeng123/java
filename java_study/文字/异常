1、异常
     * 异常即是一种意外，是程序运行过程中产生的一种突发（意外）
     * 事件，该事件会干扰程序的正常执行，打破程序的正常流程。
     *
     * 当异常产生时，会创建一个相关异常类的对象，该对象含有异常的
     * 相关信息。
     * 异常产生时，会在异常的上下文中寻找异常处理程序，如果没有
     * 异常处理程序，则异常产生之后的语句将不会得到执行。该异常
     * 会向上传播（传播给方法的调用端）。如果传播到main方法里，还
     * 未处理该异常，则main方法会将异常传播给JVM，此时，整个
     * 线程终止执行。在控制台会打印出异常的相关信息与堆栈的调用
     * 轨迹。该轨迹是按照方法调用的逆序打印，即离异常发生地最近
     * 的方法会最先打印。
2、 异常可以分成以下三种：
       受检异常      运行时异常           错误
       说明：运行时异常与错误统称为非受检异常。
       当异常发生时，我可以采用两种方式进行处理：
        捕获异常
        抛出异常
       说明：受检异常要求程序员在编译时显式处理，而非受检异常则不需要。
3、异常处理
     * 异常处理程序（异常处理器）
     * try {
     *      可能产生异常的程序
     * } catch (异常1) {
     *      恢复措施
     * } catch (异常2) {
     *      恢复措施
     * } ……
     * catch (异常n) {
     *      恢复措施
     * }
     *
     * try-catch的三种情况：
     * 1 try语句块中没有产生异常。此时try语句块全部执行完毕，
     * 之后执行try-catch之后的语句。
     * 2 try语句块中产生异常，catch捕获了该异常。
     * try中如果产生异常，则此时会创建一个相关异常类的对象，异常之后
     * 的语句将不会得到执行。程序会跳转到catch分支，从上到下依次使用
     * 异常类对象与每个catch中的异常类型进行匹配，哪一个catch分支
     * 匹配成功，则执行哪个catch语句块，此时异常被成功捕获。try-catch
     * 之后的语句正常执行。（最多只会执行一个catch分支）
     * 3 try语句块中产生异常，catch没有捕获该异常。
     * 当try中产生异常时，try异常之后的语句不会得到执行。程序
     * 跳转到catch分支进行异常匹配，没有匹配成功，则表示没有捕获
     * 该异常（该异常继续存在），则try-catch之后的语句不会得到
     * 执行，该异常会继续向上传播（传播给方法的调用端）。
4、finally
     * try-catch-finally
     * try-catch语句块可以同时使用finally。
     * catch与finally都是可选的。但是二者不能同时缺失。
     * finally的特征：
     * 不管try是否产生异常，也不管catch是否捕获了try中产生
     * 的异常，finally都将会得到执行。
     * 因为finally总是会得到执行（虚拟机退出的情况例外），所以
     * 我们在finally语句块中进行资源的释放是非常合适的。
     *
     * finally中的返回值会镇压try中的返回值。
5、多重捕获异常
    （1）
     * 捕获异常时，如果多个catch捕获的异常类型存在父子关系，
     * 则需要将子类型方法前面，父类型放在后面。因为子类型能够
     * 捕获的，父类型都能够捕获，如果父类型的catch放在前面，
     * 则子类型的catch永远没有机会得到执行。
    （2）
     * 当try语句块中，可能会产生多个异常，而多个异常的处理方式
     * 又完全相同时，我们就可以使用多重捕获异常。
     * 注意：不要使用多个异常的父类来代替多重捕获异常，因为父类
     * 会捕获更多的异常（我们意料之外的异常），这可能会隐藏掩盖
     * 我们程序的漏洞。
     *
     * 当使用多重异常捕获时，catch捕获异常的参数将隐式使用final
     * 来修饰。
7、throws 异常列表
     * 如果一个方法中可能会抛出受检异常，则要求该异常必须
     * 同时声明在方法的异常列表中。对于非受检异常（运行时
     * 异常与错误），则不要求声明在方法的异常列表中。
     *
     * 异常分为三种：
     * 1 受检异常（编译时异常）
     * 2 运行时异常
     * 3 错误
     * 运行时异常和错误统称为非受检异常。
     *
     * 受检异常继承Exception类或其子类。
     * （不包括RuntimeException或其子类）
     * 运行时异常继承RuntimeException或其子类。
     * 错误继承Error类或其子类。
     *
     * 受检异常与非受检异常的区别：
     * 受检异常必须在编译期间就需要明确对其进行处理，
     * 而非受检异常则不需要。
8、方法重写的第五条
     * 子类重写父类的方法，则子类方法不能比父类方法抛出更多
     * 的受检异常。（只能与父类相同，或者是父类抛出受检异常的
     * 子类异常）。对于非受检异常，则不受限制。
9、手动抛出异常
10、自定义异常
     * 为什么要使用自定义异常？
     * 1 Java类库提供的异常类不能满足所有人的需要。
     * 2 自定义异常可以令我们快速定位问题。
     *
     * 按照惯例，自定义异常名使用Exception进行结尾。
     1、class NegtiveAgeException extends RuntimeException {
         public NegtiveAgeException(String s) {
             super(s);
         }

         public NegtiveAgeException() {
             this("年龄为负数，请输入核对！");
         }

     2、public void deal(int age) {
         if (age <= 0) {
             throw new NegtiveAgeException("年龄为负！" + age);
         }
         System.out.println("年龄合理，进行处理。");
     }