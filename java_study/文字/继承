1、成员的继承
    1当子类与父类在同一个包中时，子类继承父类
    public，protected与默认访问全限定的成员。
    2当子类与父类不在同一个包中时，子类继承父类
    public，protected访问权限的成员。
2、继承的关键字
    继承使用extends关键字。
3、构造器的继承
    （1）构造器的“继承”
        构造器不是方法，也不是类的成员。构造器
    不能被子类所继承。（public的构造器也不能）。
    虽然子类不会继承父类的构造器，但是在子类的构造器
    中，会首先调用父类的构造器。这是一个递归的过程，
    一直调用到Object类的构造器为止。
        如果子类构造器中没有显式的调用父类的构造器，则会调用
    父类无参的构造器。（编译器会自动生成一条语句：super()）
    此时，如果父类没有无参的构造器，将会 产生编译错误。
    （2）子类中通过super调用父类的构造器。
        使用super调用父类构造器的规则：
        1 需要使用super调用父类构造器，而不能使用父类构造器
    的名字。
        2 只能在子类的构造器中调用父类的构造器，而不能在
    子类构造器之外调用父类的构造器。
        3 使用super调用父类构造器，必须是子类构造器中的第一条
    语句。
    （3）编译器自动补充super调用父类构造器的情况：
        子类构造器中没有显式的调用父类构造器，又没有使用this
    调用子类其他构造器时，编译器才会补充super()语句，调用
    父类无参的构造器。如果子类构造器中使用this调用了其他
    构造器，则编译器不会补充super()语句，以免进行重复的
    初始化。
4、super关键字的使用
    1 通过super可以调用父类的构造器
    2 通过super可以访问父类的成员。
6、方法的重写
    （1）方法重写
    父类中的方法，在子类中重新又声明一次，就是方法重写。
    （2）重写的规则：
        1 子类方法与父类方法具有相同的名字。
        2 子类方法参数列表需要与父类相同或者与父类擦除后相同。
        3 子类方法的返回类型是父类方法返回类型的可替换类型。
            a、可替换类型：
                如果是基本数据类型（包含void），则要求子类方法的返回类型
                与父类方法的返回类型一致。
                如果是引用类型，则要求子类方法的返回类型与父类方法一致，
                或者是父类方法返回类型的子类型。
        4 子类方法的访问权限不能低于父类方法的访问权限（可以相同）。
        5 子类方法不能比父类方法抛出更多的受检异常。
            我们可以使用@Override注解给编译器提供重写的信息。
            如果@Override标记的方法没有重写父类的方法，将会
            产生编译错误。
7、成员变量的隐藏
    成员变量的隐藏
    在子类中声明了与父类同名的变量，则称
    子类隐藏了父类同名的成员变量。
8、父类引用与子类引用（对象）
    （1）父类的引用既可以指向父类的对象，也可以指向子类
    的对象（因为子类是一种特殊的父类，所有的子类都
    是父类），子类的引用可以指向子类的对象，但是不能
    指向父类的对象。
        子类可以赋值给父类，但父类不能赋值给子类。

    （2）引用类型之间的转换：
        1 自动转换 子类型向父类型的转换（向上转型）
        2 强制转换 父类型向子类型的转换（向下转型）
        当进行强制转换时，父类引用指向必须是子类对象时，
    才能够真正的转换成子类的类型，否则，编译时没有
    问题，但在运行时会产生ClassCastException异常。

        引用类型转换只能发生在具有父子关系的两个类型
    之间，而不能发生在无父子关系的类型之间（编译
    错误）。

        通过父类的引用不能访问子类新增的成员。即使
     父类的引用指向的确实是一个子类的对象也不行。
11、重写与隐藏
        实例方法可以被子类重写，静态方法，静态成员变量
    与实例成员变量只能被子类隐藏，不能被子类重写。
        重写可以实现多态，是根据运行时引用指向的对象真正
    类型，来决定调用哪一个类的成员（实例方法）。
        隐藏不能实现多态，是根据编译时引用的类型来决定
    访问哪一个成员。
        能否实现多态，是重写与隐藏的本质区别。