1、内部类
     * 内部类：声明在一个类的内部的类。之前没有声明
     * 在另外一个类的内部的类，称之为顶层类。包含内部
     * 类的类，称为外围类。
     *
     * 顶层类可以声明为public，默认访问权限。
     * 内部类可以是任意的访问权限。
     *
     * 内部类的作用：
     * 1 可以令内部类与外围类关系更加紧密。
     * 2 内部类可以提供更好地访问权限的控制。
     *
     * 内部类与外围类可以自由的访问彼此的成员。（
     * 包括声明为private的成员。）
     *
     * 内部类可以分为以下几种：
     * 1 静态成员类
     * 2 实例成员类
     * 3 局部类
     * 4 匿名类

2、静态成员类
     * 静态成员类
     * 静态成员类使用static修饰。
     * 静态成员类类似于类中声明的静态成员变量。
     * 静态成员类不依赖于外围类的对象而存在。在访问静态成员类时，
     * 不需要创建外围类的对象。
     * 在外围类的内部，可以直接通过静态成员类的名字对静态成员类
     * 进行访问。
     * 在外围类的外部，需要使用外围类.静态成员类来访问静态成员类。
     * 静态成员类不能访问外围类的实例成员。（类似于静态方法不能
     * 访问实例成员）

3、实例成员类
     * 实例成员类
     * 实例成员类作为外围类的成员，不使用static修饰。
     * 实例成员类类似实例成员变量。
     * 实例成员类依赖于外围类的对象，如果我们要创建实例
     * 成员类的对象，则必须首先创建外围类的对象。
     * 实例成员类可以访问外围类的实例成员。（静态成员类不能）
     * 实例成员类不能声明任何静态上下文环境。（静态成员变量，
     * 静态方法，静态初始化块） （静态成员类可以）
     * 例外：实例成员类可以声明静态编译时常量。（final）
     * 因为在编译过后，字节码直接使用的是静态final的常量值。
     * 而不存在该静态成员变量。
5、局部类
    (1)
     * 局部类：声明在方法，语句块等局部范围内的类。
     * 局部类类似于方法中声明的局部变量。
     * 局部类不能使用static修饰，也不能使用访问修饰符修饰
     * （因为局部变量不能使用以上关键字修饰）。
     * 局部类不能声明静态成员。
     * 如果局部类处于静态的上下文环境中，则局部类不能访问
     * 外围类的实例成员。（可以访问静态成员。）
     * 如果局部类处于实例的上下文环境中，则局部类可以访问
     * 外围类静态与实例的成员。
    (2)
      * 局部类仅在声明的位置开始，到其所在的最小语句块结束。
      * 局部类的对象在局部范围（声明局部类的范围，即局部类的作用域）
      * 之外不能使用，为了能够让局部对象存活在局部范围之外，通过
      * 令局部类实现一个接口，然后在方法中返回接口类型。也就是
      * 将局部类的对象作为接口类型返回。
    (3)
     * 局部类对局部变量的访问
     * 在JavaSE 8之前，局部类只能访问声明为final的
     * 局部变量。
     * 从JavaSE 8开始，局部类也能访问声明为非final的
     * 局部变量，前提是，该局部变量的值，没有发生更改。
     * （final等效的局部变量）
7、匿名类
     (1)
     * 当局部类只用到一次，并且局部类的类体相对较短时，
     * 我们可以使用匿名类来代替局部类，这样可以是程序
     * 更加简洁。
     (2)
     * 匿名类
     * 匿名类就是没有名字的类。
     * 匿名类集类的声明与创建对象为一体，即在声明类的同时
     * 创建匿名类的对象。
     *
     * 对于匿名类的语法，new T() {}创建的并不是T类型的对象，
     * 而是T的子类型的对象（匿名类类型的对象）。如果T是一个类，
     * 则匿名类继承T。如果T是一个接口，则匿名类实现接口T。
     *
     * 在匿名类中，不能声明构造器。因为匿名类没有名字。
8、内部类的字节码文件命名
     * 与顶层类一样，在编译过后，内部类也会生成字节码文件（.class)。
     * 对于成员类（静态成员类与实例成员类），生成的class文件名
     * 为--外围类$成员类.class
     * 对于局部类，生成的class文件名为--外围类$数字局部类.class
     * 对于匿名类，生成的class文件名为--外围类$数字.clas
9、函数式接口
     * 如果接口中有且仅有一个抽象的方法（这里的抽象方法不包括
     * 从Object类中继承的方法），则这样的接口
     * 称为函数式接口。对于默认方法与静态方法，没有要求。
     *
     * 我们可以使用@FunctionalInterface来对一个接口进行标记，
     * 表示该接口为函数式接口。
